\documentclass[a4paper]{article}

\usepackage[french]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{fullpage}
\usepackage{pgf}
\usepackage{tikz}
\usetikzlibrary{arrows,automata}
\usetikzlibrary{positioning}

\begin{document}

\title{Compilateur pour MiniC : production de code}
\author{Thomas Bourgeat et Antonin Delpeuch}
\date{\today}

\maketitle

\section{Architecture}

Nous avons adopté l'architecture présentée lors des deux derniers cours, à un détail près :
nous ne passons pas par l'étape de sélection d'instructions, ou plutôt nous la réalisons
directement pendant la traduction vers RTL. Le code est ensuite traduit en ERTL puis LTL et
il est enfin linéarisé.

\section{RTL}

En traduisant l'arbre typé en RTL, on s'est rendu compte que c'était bien plus pratique si
les constructions \texttt{a->b} et \texttt{t[n]} avaient déjà été traduites en leurs équivalents,
respectivement \texttt{(*a).b} et \texttt{*(t + n)}.

De même, on a profité de l'étape de typage pour expliciter les facteurs dans l'arithmétique de pointeur,
ce qui est possible car on calcule les \texttt{sizeof} dès le typage.

Pendant l'étape de traduction vers RTL, on a tiré parti des opérandes immédiates disponibles en MIPS
pour éviter des codes du type \texttt{li  \$t0 1 ; add \$t1 \$t2 \$t0}.

\texttt{TODO : simplification des if(a || b)}

La gestion des types était une des difficultés de cette étape. Quand il s'agit d'opérations sur des types
numériques (\texttt{char}, \texttt{int} et pointeurs), un pseudo-registres suffit. Pour les \texttt{struct}
et les \texttt{union}, le pseudo-registre associé contient l'adresse d'un emplacement sur la pile (dans la
\emph{frame} de la fonction) où est stocké la structure. Il faut ensuite implémenter les opérations
d'affectation pour que le contenu de la structure soit déplacée vers l'emplacement cible.

\section{ERTL}
Tout d'abord nos Label sont la suite de ceux utilisés dans RTL, et à
aucun moment lors de la compilation nous réinitialisons le compteur de
Label. Nous avons construit notre fonction principale
\texttt{compile\_instr} comme un morphisme.

Le point délicat de l'application de ce morphisme, réside dans le \texttt{let ... in} de l'expression suivante :
\texttt{Rtl.M.iter (fun x y -> let a = compil\_instr y in graph:= M.add
x a (!graph)) g}. En effet, \texttt{graph} étant une référance globale, elle est
modifiée par \texttt{compil\_instr} et l'ordre d'évaluation des appels
de fonctions semble être de droite à gauche, ce qui donc pose problème
puisqu'\texttt{iter} charge \texttt{!graph} avant qu'il soit modifié. Une simple inversion des
deux derniers arguments de add aurait surement suffit, mais la solution que l'on a choisit est
plus sure, ne dépendant pas des conventions de l'évaluation stricte.
\section{LTL}
\subsection{Algorithme de Kildall}

Nous avons implémenté l'algorithme de Kildall comme suggéré dans le cours. Nous avons d'abord précalculé
les successeurs directs et les prédécesseurs (directs ou indirects) pour pouvoir mettre à jour la liste de
travail plus facilement. On réalise ce précalcul en parcourant le graphe transposé (en profondeur d'abord).
Pour éviter de faire un DFS par nœud on réutilise les résultats des DFS précédents.

\subsection{Iterated Register Coalescing}

Nous avons implémenté l'algorithme d'Appel décrit dans \emph{Modern Compiler Implementation in ML}.
Nous nous sommes largement appuyés sur le pseudo-code donné dans ce livre. La première différence avec
leur algorithme est que nous ne réitérons pas le coloriage après avoir spillé des pseudo-registres :
nous réservons deux pseudo-registres pour effectuer les \texttt{lw} et \texttt{sw} nécessaires au spill.
La seconde différence est que s'il faut spiller un registre, nous le choisissons arbitrairement (parmi ceux
qui ont un grand degré).

Nous pensons avons constaté un problème dans le pseudo-code de George et Appel. \texttt{À développer}

\texttt{TODO : importance de l'heuristique de choix de spill}
\texttt{TODO : une phase ou plus ?}

\subsection{Traduction LTL}

Cette étape est structurellement très proche de la traduction RTL->ERTL.
Nous avons réutilisé l'idée du cours des fonctions \texttt{read} et
\texttt{write} pour gérer à l'aide de 2 registres physiques
les accès aux registres spillés. 

\subsection{Linéarisation}

\subsubsection{Le problème des immediate}
Tout d'abord, les spécifications MIPS précisent que ce que l'on appelle
les
 immediate sont des entiers 16 bits. Ceci a été un problème, jusqu'à ce
 qu'on découvre que l'assembleur fait le travaille pour nous, et que ce
 sont des pseudoinstructions qui gèrent des offset de plus de 16 bits.
 Il reste cependant un cas, une des comparaisons n'est pas une
 pseudoinstruction. Nous avons donc résolu ce cas durant la linéarisation.
Enfin, il reste des \texttt{int}, pour les offset, ça pourrait sembler
dommage, mais le fichier mips.ml utilisait des int aussi. Ceci
n'est limitant que dans une portion moindre : l'offset maximum est
d'alors à peu près 1Go. Rigoureusement, une fonction avec une frame de 1.5Go fera
faire n'importe quoi au compilateur.

\subsection{Schéma de la frame}

Il a été nécessaire de fixer une convention pour la frame. Vu que nous
utilisons uniquement \texttt{FP} pour gérer la pile, 
et que donc nous commencons par gérer "vu du haut"
les arguments qui seront passés sur la pile, nous avons décidé de mettre
le plus haut les arguments. En effet dans Ertl, nous n'avons pas
connaissance encore des pseudoregistres spillés et des tailles de
structures. Puis les registres spillés, puis les structures.
 
TODO inclure magnifique dessin Antonin

 Parler de l'instruction \texttt{Einit\_addr}.
\subsection{Quand Not ne fonctionne pas}
Un petit problème que l'on a rencontré concerne la signification de neg
en Mips, ce n'est pas une négation logique, mais un moins unaire. Guidé
par la terminologie et par le fait que nous avions besoin d'une négation
logique nous nous sommes aperçu de ce problème au moment du débuggage,
nous avons décidé alors de simplement changer le printer dans mips.ml,
pour faire un \texttt{seq r1,r2, \$0}
\end{document}


