\documentclass[a4paper]{article}

\usepackage[french]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{fullpage}
\usepackage{pgf}
\usepackage{tikz}
\usetikzlibrary{arrows,automata}
\usetikzlibrary{positioning}

\begin{document}

\title{Compilateur pour MiniC : analyse syntaxique et typage}
\author{Thomas Bourgeat et Antonin Delpeuch}
\date{\today}

\maketitle

\section{Architecture}

Nous avons fait le choix d'utiliser deux types d'arbres aux différents
stades de la compilation, le premier est crée au parsing, le deuxième au
typage :
\begin{itemize}
    \item Un arbre de syntaxe abstraite étiqueté par la position des
expressions dans le source initial.
    \item Un arbre sémantique étiqueté par les types de chaque
expression.
(pour les nœuds où cette information est utile dans la phase de
production de code)
\end{itemize}

\section{Analyse lexicale}

Nous avons utilisé \texttt{ocamllex} comme conseillé.
Cette partie n'a pas été des plus créatives, nous avons essentiellement suivi les directives du cours (enfin, on espère !).

\section{Analyse syntaxique}

\subsection{Construction de l'arbre}

Nous avons recontré deux problèmes en utilisant \texttt{menhir} :
\begin{itemize}
    \item Les règles qui définissent la déclaration de variables globales et la déclaration de fonctions entraient en conflit.
          Les règles étaient définies comme suit :
          \begin{itemize}
              \item $<type> <var>+,\texttt{;}$ où \emph{var} était définie par $<ident> | \texttt{*} <var>$
              \item $<type> \texttt{*}* <ident>\texttt{(} <argument>*, \texttt{);}$
          \end{itemize}
          Le problème est que pour reconnaître une déclaration de variable, l'automate doit réduire \texttt{*}*\emph{<ident>} en un \emph{<var>}, car si ce n'est pas fait directement un autre caractère sera empilé, or l'automate ne peut réduire qu'un ensemble de termes en haut de la pile. Mais alors, un fois ces termes réduits, l'automate ne peut plus reconnaître une déclaration de fonction, puisque \emph{<var>} ne figure pas dedans.

          Nous avons résolu ce conflit en réécrivant les règles en question.

      \item Nous avons été confrontés au conflit classique dû à la structure \texttt{if (…) … else …}.
            Le comportement par défaut de \texttt{menhir} sur ce conflit (favoriser la lecture, le \emph{shift}) est celui qui est attendu. Nous avons vérifié que l'arbre obtenu est bien le bon (voir section~\ref{subsec:html}).
\end{itemize}

\subsection{Étiquetage}

Pour étiqueter les nœuds de l'arbre syntaxique, nous avons déclaré un lexème paramétrable :

\begin{verbatim}
labeled(X):
   | x = X { (make_label $startpos $endpos), x }
\end{verbatim}

C'est un moyen assez peu intrusif d'étiqueter les nœuds, à condition bien sûr de mettre à jour le type de l'arbre.

\subsection{Vérification de la correction}
\label{subsec:html}

Nous avons mis en place un système de tests avec un script shell, mais il vérifie uniquement si le code de retour est bien celui qu'on attendait.
Dans le cas où l'analyse a réussi, cette vérification est insuffisante puisqu'il faut s'assurer que l'arbre construit est bien celui qu'on attendait.
C'est particulièrement important quand il s'agit de vérifier la gestion des priorités opératoires, par exemple.

Pour vérifier si l'arbre généré est bien l'arbre attendu, nous avons écrit un module qui fait la traduction inverse :
à partir d'un arbre syntaxique il écrit un code source.
Le code source généré est écrit en HTML, ce qui permet d'ajouter de la coloration syntaxique au passage.
Les étiquettes qui indiquent la position dans le source initial ne sont pas perdues :
il suffit de survoler un lexème pour voir s'afficher sa position.
Pendant cette génération, beaucoup de parenthèses sont ajoutées, de sorte qu'il devient facile de vérifier si l'arbre généré est bien le bon.

\section{Typage}

\appendix
\section{Conventions de nommage}

Les types commencent par une lettre indiquant dans quel contexte on les utilise :
\begin{itemize}
    \item \texttt{a} comme dans \texttt{aexpr} : type utilisé dans l'arbre de syntaxe abstraite pour représenter un nœud.
    \item \texttt{l} comme dans \texttt{lident} : équivalent étiqueté (par une position dans le source) du type précédent.
    On définit généralement \texttt{l\emph{type} = label * a\emph{type}}.
\item \texttt{w} comme dans \texttt{wexpr} : arbre dont la descendance est étiquetée par des types C
\item \texttt{t} comme dans \texttt{texpr} : équivalent étiqueté par un type C du type précédent, généralement défini par \texttt{t\emph{type} = expr\_type * w\emph{type}}.
\end{itemize}

Les constructeurs de chaque type sont préfixés par des majuscules indiquant quel type ils construisent :
\begin{itemize}
    \item \texttt{AU} : opérateur unaire dans un arbre de syntaxe étiqueté par des positions
    \item \texttt{AB} : idem pour un opérateur binaire
    \item \texttt{AE} : une expression dans l'AST (équivalent du \emph{<expr>} du sujet)
    \item \texttt{AI} : une instruction dans l'AST
    \item \texttt{ET} : un type qui peut être affecté à une expression (Expresion Type)
    \item \texttt{TE} : une expression typée (Typed Expression), pour construire l'AST typé
\end{itemize}

\end{document}


